{% extends "base.html" %}

{% block content %}
<div class="roster-container mt-4 mb-5">
    <!-- Game Info Header -->
    <div class="card mb-4">
        <div class="card-body py-3">
            <div class="row align-items-center text-center">
                <div class="col-md-5">
                    <h5 class="mb-0 text-primary fw-bold">{{ roster.event.home_team.name }}</h5>
                    <small class="text-muted">Home</small>
                </div>
                <div class="col-md-2">
                    <span class="badge bg-secondary fs-6">VS</span>
                </div>
                <div class="col-md-5">
                    <h5 class="mb-0 text-danger fw-bold">{{ roster.event.away_team.name }}</h5>
                    <small class="text-muted">Away</small>
                </div>
            </div>
            <hr class="my-2">
            <div class="row text-center">
                <div class="col-md-6">
                    <small class="text-muted"><i class="bi bi-clock"></i> {{ event_time_display|date:"m/d/y, g:i A" }}</small>
                </div>
                <div class="col-md-6">
                    <small class="text-muted"><i class="bi bi-geo-alt"></i> {{ roster.event.location|default:"TBD" }}</small>
                </div>
            </div>
        </div>
    </div>

    <!-- Innings Tabs -->
    <ul class="nav nav-tabs mt-4" id="inningTabs" role="tablist">
        {% for inning in innings_range %}
        <li class="nav-item" role="presentation">
            <button class="nav-link {% if inning == 1 %}active{% endif %} inning-tab" id="inning{{ inning }}-tab" data-bs-toggle="tab" data-bs-target="#inning{{ inning }}" type="button" role="tab" data-inning="{{ inning }}">
                <i class="bi bi-diamond-fill"></i><span class="inning-label">Inning {{ inning }}</span>
                <i class="bi bi-check-circle-fill validation-icon valid-icon"></i>
                <i class="bi bi-x-circle-fill validation-icon invalid-icon"></i>
            </button>
        </li>
        {% endfor %}
        <li class="nav-item" role="presentation">
            <button class="nav-link lineup-tab" id="lineup-tab" data-bs-toggle="tab" data-bs-target="#lineup" type="button" role="tab">
                <i class="bi bi-list-ol"></i><span class="lineup-label">Lineup</span>
                <i class="bi bi-check-circle-fill validation-icon lineup-valid-icon"></i>
                <i class="bi bi-x-circle-fill validation-icon lineup-invalid-icon"></i>
            </button>
        </li>
        <li class="nav-item nav-divider" aria-hidden="true"></li>
        <li class="nav-item action-item" role="presentation">
            <button class="nav-link action-btn" id="shareRosterBtn" type="button" data-bs-toggle="modal" data-bs-target="#shareRosterModal">
                <i class="bi bi-share"></i><span>Share</span>
            </button>
        </li>
        <li class="nav-item action-item" role="presentation">
            <button class="nav-link action-btn" id="reuseRosterBtn" type="button" data-bs-toggle="modal" data-bs-target="#reuseRosterModal">
                <i class="bi bi-arrow-repeat"></i><span>Reuse</span>
            </button>
        </li>
        <li class="nav-item action-item" role="presentation">
            <button class="nav-link action-btn" id="manualSaveBtn" type="button">
                <i class="bi bi-check2-circle"></i><span>Save</span>
            </button>
        </li>
        <li class="nav-item action-item" role="presentation">
            <button class="nav-link action-btn" id="pdfBtn" type="button">
                <i class="bi bi-file-earmark-pdf"></i><span>PDF</span>
            </button>
        </li>
    </ul>

    <!-- Toast Message -->
    <div class="save-toast" id="saveToast">
        <i class="bi bi-check-circle-fill me-2"></i>Changes saved
    </div>

    <!-- Reuse Previous Roster Modal -->
    <div class="modal fade" id="reuseRosterModal" tabindex="-1" aria-labelledby="reuseRosterModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="reuseRosterModalLabel">Reuse Previous Game's Roster</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning mb-4">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <strong>Warning:</strong> Loading a previous game's roster will replace all of your current field assignments and batting lineup for this game.
                    </div>

                    <div class="mb-3">
                        <label for="previousGameSelect" class="form-label fw-bold">Select a previous game:</label>
                        <select class="form-select" id="previousGameSelect">
                            <option value="">-- Select a game --</option>
                        </select>
                        <div class="form-text" id="noGamesMessage" style="display: none;">
                            No previous games with roster data found.
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="loadPreviousRosterBtn" disabled>
                        <i class="bi bi-arrow-repeat me-1"></i>Load Roster
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Share Roster Modal -->
    <div class="modal fade" id="shareRosterModal" tabindex="-1" aria-labelledby="shareRosterModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="shareRosterModalLabel">Share Roster</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <!-- Invalid roster message (shown when roster is incomplete) -->
                    <div id="shareInvalidMessage" style="display: none;">
                        <div class="alert alert-warning mb-3">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>
                            <strong>Roster Not Ready</strong>
                        </div>
                        <p>You cannot share this roster until it is fully valid. Please ensure:</p>
                        <ul class="mb-3">
                            <li>All innings have valid field assignments</li>
                            <li>The batting lineup is complete and valid</li>
                        </ul>
                        <p class="text-muted small">Check each Inning tab and the Lineup tab to see which items need attention.</p>
                    </div>

                    <!-- Valid roster message (shown when roster is complete) -->
                    <div id="shareValidMessage" style="display: none;">
                        {% if opposing_manager %}
                        <p>Click below to share a read-only link to this roster with the opposing team's manager:</p>

                        <div class="card bg-light mb-3">
                            <div class="card-body">
                                <div class="mb-2">
                                    <strong>To:</strong> {{ opposing_manager.first_name }} {{ opposing_manager.last_name }}
                                </div>
                                <div class="mb-2">
                                    <strong>Email:</strong> {{ opposing_manager.email }}
                                </div>
                                <div class="mb-2">
                                    <strong>Team:</strong> {{ opposing_team.name }}
                                </div>
                                <hr>
                                <div class="mb-2">
                                    <strong>Link that will be shared:</strong>
                                </div>
                                <code class="small d-block bg-white p-2 rounded border" id="sharedRosterUrl"></code>
                            </div>
                        </div>

                        <div class="alert alert-info mb-0">
                            <i class="bi bi-info-circle me-2"></i>
                            The shared roster is read-only and does not expose your team's private portal link.
                        </div>
                        {% else %}
                        <div class="alert alert-warning">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>
                            <strong>No Opposing Manager Found</strong>
                        </div>
                        <p>The opposing team does not have a manager assigned. Please contact the league administrator to assign a manager to {{ opposing_team.name|default:"the opposing team" }}.</p>
                        {% endif %}
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    {% if opposing_manager %}
                    <button type="button" class="btn btn-primary" id="sendShareEmailBtn" style="display: none;">
                        <i class="bi bi-envelope me-1"></i>Send Email
                    </button>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>

    <!-- Reset Inning Confirmation Modal -->
    <div class="modal fade" id="resetInningModal" tabindex="-1" aria-labelledby="resetInningModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="resetInningModalLabel">Reset Inning</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning mb-3">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <strong>Warning:</strong> This action cannot be undone.
                    </div>
                    <p>Are you sure you want to reset <strong id="resetInningNumber">Inning 1</strong>? This will clear all position assignments for this inning.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirmResetInningBtn">
                        <i class="bi bi-arrow-counterclockwise me-1"></i>Reset Inning
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tab Content -->
    <div class="tab-content mt-4" id="inningTabContent">
        {% for inning in innings_range %}
        <div class="tab-pane fade {% if inning == 1 %}show active{% endif %}" id="inning{{ inning }}" role="tabpanel">
            <div class="row g-3">
                <!-- Left Column: Player List -->
                <div class="col-md-6">
                    <div class="roster-section">
                        <h5 class="section-header">Available Players</h5>
                        <div class="player-list" id="playerList{{ inning }}">
                            {% for player in team.players.all %}
                            <div class="player-card" draggable="true" data-player-id="{{ player.id }}" data-player-name="{{ player.first_name }} {{ player.last_name }}">
                                {{ player.first_name }} {{ player.last_name }}
                            </div>
                            {% endfor %}
                            <div class="all-assigned-message" id="allAssignedMessage{{ inning }}" style="display: none;">
                                <i class="bi bi-check-circle-fill text-success me-2"></i>
                                <span>All players have been assigned a position.</span>
                                <span class="inning-valid-text text-success fw-bold"> Inning is now valid.</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Baseball Field -->
                <div class="col-md-6">
                    <div class="roster-section">
                        <div class="d-flex justify-content-between align-items-center section-header">
                            <span>Field Positions</span>
                            <div class="d-flex gap-2">
                                <button class="btn btn-outline-danger btn-sm reset-inning-btn" data-inning="{{ inning }}">
                                    Reset Inning
                                </button>
                                <div class="dropdown reuse-inning-dropdown" id="reuseInningDropdown{{ inning }}">
                                    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        Reuse Inning
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-end" id="reuseInningMenu{{ inning }}">
                                        <!-- Dynamically populated by JavaScript -->
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class="baseball-field" data-inning="{{ inning }}">
        <svg viewBox="0 -15 600 655" class="field-svg">
            <!-- Infield dirt (90 foot diamond + extended areas) -->
            <path d="M 300 510.625 L 70 352.5 L 300 194.375 L 530 352.5 Z"
                  fill="#d4a574" stroke="none"/>

            <!-- Dirt cutout around pitcher/home plate -->
            <ellipse cx="300" cy="510.625" rx="86.25" ry="57.5" fill="#d4a574" stroke="none"/>
            <circle cx="300" cy="352.5" r="43.125" fill="#d4a574" stroke="none"/>

            <!-- Basepaths (dirt lines) -->
            <line x1="300" y1="510.625" x2="70" y2="352.5" stroke="#c19a6b" stroke-width="5"/>
            <line x1="300" y1="510.625" x2="530" y2="352.5" stroke="#c19a6b" stroke-width="5"/>
            <line x1="70" y1="352.5" x2="300" y2="194.375" stroke="#c19a6b" stroke-width="5"/>
            <line x1="530" y1="352.5" x2="300" y2="194.375" stroke="#c19a6b" stroke-width="5"/>

            <!-- Pitcher's mound -->
            <circle cx="300" cy="352.5" r="31.625" fill="#b8885c" stroke="#a67c52" stroke-width="2"/>

            <!-- Bases -->
            <rect x="295" y="189.375" width="10" height="10" fill="white" stroke="#999" stroke-width="1" transform="rotate(45 300 194.375)"/>
            <rect x="525" y="347.5" width="10" height="10" fill="white" stroke="#999" stroke-width="1" transform="rotate(45 530 352.5)"/>
            <rect x="65" y="347.5" width="10" height="10" fill="white" stroke="#999" stroke-width="1" transform="rotate(45 70 352.5)"/>

            <!-- Home plate -->
            <polygon points="300,521.875 294.25,515 294.25,510.625 305.75,510.625 305.75,515" fill="white" stroke="#999" stroke-width="1"/>

            <!-- Position markers (drop zones) -->
            <!-- Outfielders - spread far out and deeper -->
            {% if allow_four_outfielders %}
            <!-- Four Outfielders Layout -->
            <g class="position-marker" data-position="LF" draggable="true">
                <circle cx="70" cy="73.125" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="70" y="79.125" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">LF</text>
                <text x="70" y="128.125" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="98" cy="45.125" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="98" y="51.125" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            <g class="position-marker" data-position="CF-L" draggable="true">
                <circle cx="220" cy="39.375" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="220" y="45.375" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">CF-L</text>
                <text x="220" y="94.375" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="248" cy="11.375" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="248" y="17.375" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            <g class="position-marker" data-position="CF-R" draggable="true">
                <circle cx="380" cy="39.375" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="380" y="45.375" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">CF-R</text>
                <text x="380" y="94.375" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="408" cy="11.375" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="408" y="17.375" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            <g class="position-marker" data-position="RF" draggable="true">
                <circle cx="530" cy="73.125" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="530" y="79.125" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">RF</text>
                <text x="530" y="128.125" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="558" cy="45.125" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="558" y="51.125" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>
            {% else %}
            <!-- Three Outfielders Layout -->
            <g class="position-marker" data-position="LF" draggable="true">
                <circle cx="70" cy="73.125" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="70" y="79.125" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">LF</text>
                <text x="70" y="128.125" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="98" cy="45.125" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="98" y="51.125" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            <g class="position-marker" data-position="CF" draggable="true">
                <circle cx="300" cy="39.375" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="300" y="45.375" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">CF</text>
                <text x="300" y="94.375" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="328" cy="11.375" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="328" y="17.375" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            <g class="position-marker" data-position="RF" draggable="true">
                <circle cx="530" cy="73.125" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="530" y="79.125" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">RF</text>
                <text x="530" y="128.125" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="558" cy="45.125" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="558" y="51.125" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>
            {% endif %}

            <!-- Infielders - spread around diamond -->
            <g class="position-marker" data-position="3B" draggable="true">
                <circle cx="70" cy="352.5" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="70" y="358.5" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">3B</text>
                <text x="70" y="407.5" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="98" cy="324.5" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="98" y="330.5" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            <g class="position-marker" data-position="SS" draggable="true">
                <circle cx="156.25" cy="244.6875" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="156.25" y="250.6875" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">SS</text>
                <text x="156.25" y="299.6875" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="184.25" cy="216.6875" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="184.25" y="222.6875" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            <g class="position-marker" data-position="2B" draggable="true">
                <circle cx="443.75" cy="244.6875" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="443.75" y="250.6875" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">2B</text>
                <text x="443.75" y="299.6875" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="471.75" cy="216.6875" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="471.75" y="222.6875" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            <g class="position-marker" data-position="1B" draggable="true">
                <circle cx="530" cy="352.5" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="530" y="358.5" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">1B</text>
                <text x="530" y="407.5" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="558" cy="324.5" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="558" y="330.5" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            <g class="position-marker" data-position="P" draggable="true">
                <circle cx="300" cy="352.5" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="300" y="358.5" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">P</text>
                <text x="300" y="407.5" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="328" cy="324.5" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="328" y="330.5" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>

            {% if allow_rover_position %}
            <g class="position-marker" data-position="R" draggable="true">
                <circle cx="300" cy="194.375" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="300" y="200.375" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">R</text>
                <text x="300" y="249.375" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="328" cy="166.375" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="328" y="172.375" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>
            {% endif %}

            <g class="position-marker" data-position="C" draggable="true">
                <circle cx="300" cy="557.125" r="40" fill="rgba(255,255,255,0.9)" stroke="#333" stroke-width="2" class="position-circle"/>
                <text x="300" y="563.125" text-anchor="middle" font-size="14" font-weight="bold" fill="#666" class="position-label">C</text>
                <text x="300" y="612.125" text-anchor="middle" font-size="11" fill="#333" class="player-name-display"></text>
                <g class="remove-player-btn" style="display: none; cursor: pointer;">
                    <circle cx="328" cy="529.125" r="12" fill="#dc3545" stroke="white" stroke-width="2"/>
                    <text x="328" y="535.125" text-anchor="middle" font-size="16" font-weight="bold" fill="white">×</text>
                </g>
            </g>
        </svg>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        {% endfor %}

        <!-- Lineup Tab Pane -->
        <div class="tab-pane fade" id="lineup" role="tabpanel">
            <div class="row g-3">
                <div class="col-12">
                    <div class="roster-section lineup-section">
                        <div class="lineup-table-container">
                            <table class="table lineup-table" id="lineupTable">
                                <thead>
                                    <tr>
                                        <th class="drag-col"></th>
                                        <th class="order-col">#</th>
                                        <th class="name-col">Player Name</th>
                                        {% for inning in innings_range %}
                                        <th class="position-col">{{ inning }}</th>
                                        {% endfor %}
                                        <th class="infield-count-col">IF Positions in<br>First 3 Innings</th>
                                        <th class="validation-col">Validation</th>
                                    </tr>
                                </thead>
                                <tbody id="lineupBody">
                                    {% for player in team.players.all %}
                                    <tr class="lineup-row" draggable="true" data-player-id="{{ player.id }}" data-player-name="{{ player.first_name }} {{ player.last_name }}">
                                        <td class="drag-col"><i class="bi bi-grip-vertical drag-handle"></i></td>
                                        <td class="order-col"><span class="batting-order"></span></td>
                                        <td class="name-col">{{ player.first_name }} {{ player.last_name }}</td>
                                        {% for inning in innings_range %}
                                        <td class="position-col position-display" data-inning="{{ inning }}">-</td>
                                        {% endfor %}
                                        <td class="infield-count-col infield-count-display">0</td>
                                        <td class="validation-col validation-status" data-bs-toggle="tooltip" data-bs-placement="left" title="">
                                            <i class="bi bi-check-circle-fill text-success validation-icon-valid" style="display: none;"></i>
                                            <i class="bi bi-x-circle-fill text-danger validation-icon-invalid" style="display: none;"></i>
                                        </td>
                                    </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>
                        <div class="lineup-info-footer mt-3">
                            <small class="text-muted">
                                <i class="bi bi-info-circle me-1"></i>
                                <strong>Infield positions:</strong> <span id="infieldPositionsList"></span>
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Wide Container for Roster Page - supports up to 9 innings + lineup + reuse + save */
.roster-container {
    max-width: 1900px;
    width: 98%;
    margin-left: auto;
    margin-right: auto;
    padding-left: 15px;
    padding-right: 15px;
}

/* Section Container Styles */
.roster-section {
    background-color: white;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 20px;
    height: 950px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.section-header {
    font-size: 16px;
    font-weight: 600;
    color: #495057;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 2px solid #e9ecef;
}

/* Player List Styles */
.player-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 4px;
    transition: background-color 0.2s ease;
}

.all-assigned-message {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 20px;
    text-align: center;
    color: #6c757d;
    font-style: italic;
    font-size: 14px;
}

.all-assigned-message .inning-valid-text {
    display: block;
    margin-top: 8px;
    font-style: normal;
}

.player-card {
    padding: 12px 16px;
    background-color: white;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-size: 14px;
    text-align: left;
    cursor: grab;
    transition: all 0.2s;
}

.player-card:hover {
    background-color: #f8f9fa;
    border-color: #0d6efd;
    transform: translateX(3px);
}

.player-card:active {
    cursor: grabbing;
    opacity: 0.6;
}

.player-card.dragging {
    opacity: 0;
    visibility: hidden;
}

.player-card.assigned {
    display: none;
}

/* Baseball Field Styles */
.baseball-field {
    width: 100%;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #6ba368;
    border-radius: 4px;
    padding: 20px;
    margin-top: -20px;
}

.field-svg {
    width: 90%;
    height: 90%;
    max-width: none;
}

.position-marker {
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    -webkit-user-select: none;
    pointer-events: all;
}

.position-marker .position-circle,
.position-marker .position-label,
.position-marker .player-name-display {
    pointer-events: all;
}

/* Removed hover effect - only show drop zone during drag */

.position-marker.has-player {
    cursor: grab;
}

.position-marker.has-player:active {
    cursor: grabbing;
}

.position-marker.has-player .position-circle {
    fill: #d1e7dd;
    stroke: #198754;
    stroke-width: 3;
}

.position-marker.drag-over .position-circle {
    fill: #cfe2ff;
    stroke: #0d6efd;
    stroke-width: 4;
}

/* Swap indicator - shows when dragging to swap two players */
.position-marker.drag-over-swap .position-circle {
    fill: #fff3cd;
    stroke: #fd7e14;
    stroke-width: 4;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.player-name-display {
    font-weight: 600;
    fill: #333;
}

.remove-player-btn {
    pointer-events: all;
    cursor: pointer !important;
}

.remove-player-btn:hover circle {
    fill: #c82333;
}

.position-marker.has-player:has(.remove-player-btn:hover) {
    cursor: pointer !important;
}

/* Tab Styles - Card Style */
.nav-tabs {
    border-bottom: none;
    gap: 8px;
    display: flex;
    flex-wrap: nowrap;
    width: 100%;
}

.nav-tabs .nav-item {
    flex: 1 1 0;
    min-width: 0;
}

/* Divider between content tabs and action buttons */
.nav-tabs .nav-divider {
    flex: 0 0 auto;
    width: 1px;
    background: linear-gradient(to bottom, transparent 20%, #dee2e6 50%, transparent 80%);
    margin: 0 4px;
    min-width: 1px;
}

/* Action buttons group styling */
.nav-tabs .action-item {
    flex: 0 0 auto;
    min-width: auto;
}

.nav-tabs .action-btn {
    background-color: #f8f9fa;
    border-color: #dee2e6;
    color: #6c757d;
}

.nav-tabs .action-btn:hover {
    background-color: #e9ecef;
    border-color: #adb5bd;
    color: #495057;
}

.nav-tabs .nav-link {
    color: #495057;
    background-color: white;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px 12px;
    font-weight: 500;
    transition: all 0.2s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    white-space: nowrap;
    width: 100%;
    text-align: left;
    display: flex;
    align-items: center;
    gap: 6px;
}

/* Consistent icon styling for all tab buttons */
.nav-tabs .nav-link i.bi {
    margin-right: 0;  /* Use gap instead of margin */
    flex-shrink: 0;
}

.nav-tabs .nav-link:hover {
    background-color: #f8f9fa;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    border-color: #0d6efd;
}

.nav-tabs .nav-link.active {
    color: white;
    background-color: #0d6efd;
    border-color: #0d6efd;
    font-weight: 600;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(13,110,253,0.3);
}

/* Inning Tab Validation Styles */
.inning-tab {
    position: relative;
}

.inning-tab .validation-icon {
    font-size: 16px;
    transition: opacity 0.3s ease;
}

/* By default, show invalid icon (red X) */
.inning-tab .valid-icon {
    display: none;
}

.inning-tab .invalid-icon {
    color: #dc3545;
    opacity: 1;
}

/* When valid, show green checkmark and hide red X */
.inning-tab.valid .valid-icon {
    display: inline;
    color: #198754;
    opacity: 1;
}

.inning-tab.valid .invalid-icon {
    display: none;
}

.inning-tab.valid {
    border-color: #198754;
    background: linear-gradient(135deg, #d1e7dd 0%, #ffffff 100%);
}

.inning-tab.valid:hover {
    border-color: #198754;
    background: linear-gradient(135deg, #c3e6cb 0%, #f8f9fa 100%);
}

.inning-tab.valid.active {
    background: linear-gradient(135deg, #198754 0%, #157347 100%);
    border-color: #198754;
    color: white;
}

.inning-tab.valid.active .valid-icon {
    color: white;
}

/* Invalid state styling (when active) - keep red */
.inning-tab.active .invalid-icon {
    color: #dc3545;
}

/* Lineup Tab Styles */
.lineup-tab {
    position: relative;
}

/* Lineup Tab Validation Icons */
.lineup-tab .lineup-valid-icon {
    display: none;
    color: #198754;
}

.lineup-tab .lineup-invalid-icon {
    color: #dc3545;
}

.lineup-tab.valid .lineup-valid-icon {
    display: inline;
}

.lineup-tab.valid .lineup-invalid-icon {
    display: none;
}

.lineup-tab.valid {
    border-color: #198754;
    background: linear-gradient(135deg, #d1e7dd 0%, #ffffff 100%);
}

.lineup-tab.valid:hover {
    border-color: #198754;
    background: linear-gradient(135deg, #c3e6cb 0%, #f8f9fa 100%);
}

.lineup-tab.valid.active {
    background: linear-gradient(135deg, #198754 0%, #157347 100%);
    border-color: #198754;
    color: white;
}

.lineup-tab.valid.active .lineup-valid-icon {
    color: white;
}

.lineup-section {
    height: auto !important;
    min-height: 400px;
    max-height: calc(100vh - 300px);
}

.lineup-table-container {
    flex: 1;
    overflow-y: auto;
    overflow-x: auto;
}

.lineup-table {
    margin-bottom: 0;
    width: 100%;
}

.lineup-table thead th {
    position: sticky;
    top: 0;
    background: white;
    z-index: 10;
    border-bottom: 2px solid #dee2e6;
    font-weight: 600;
    color: #495057;
    white-space: nowrap;
    padding: 12px 8px;
}

.lineup-table .drag-col {
    width: 30px;
    text-align: center;
    padding: 12px 4px;
}

.drag-handle {
    color: #adb5bd;
    font-size: 18px;
    cursor: grab;
}

.drag-handle:hover {
    color: #6c757d;
}

.lineup-row:active .drag-handle {
    cursor: grabbing;
}

.lineup-table .order-col {
    width: 60px;
    text-align: center;
    font-weight: 700;
}

.lineup-table .name-col {
    min-width: 150px;
}

.lineup-table .position-col {
    width: 70px;
    text-align: center;
    font-size: 13px;
}

.lineup-row {
    cursor: grab;
    transition: all 0.2s ease;
    user-select: none;
}

.lineup-row:hover {
    background-color: #f8f9fa;
}

.lineup-row:active {
    cursor: grabbing;
}

.lineup-row.dragging {
    opacity: 0.5;
    background-color: #e7f1ff;
}

.lineup-row.drag-over {
    border-top: 3px solid #0d6efd;
}

.lineup-row td {
    padding: 12px 8px;
    vertical-align: middle;
}

.batting-order {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background-color: #0d6efd;
    color: white;
    border-radius: 50%;
    font-weight: 700;
    font-size: 14px;
}

.position-display {
    color: #6c757d;
}

.position-display:not(:empty) {
    color: #198754;
    font-weight: 500;
}

.lineup-table .infield-count-col {
    width: 180px;
    text-align: center;
    font-weight: 600;
    white-space: nowrap;
}

.lineup-table .validation-col {
    width: 90px;
    text-align: center;
}

.validation-status {
    cursor: help;
}

.validation-status i {
    font-size: 18px;
}

.lineup-info-footer {
    padding: 10px 15px;
    background-color: #f8f9fa;
    border-radius: 4px;
    border: 1px solid #e9ecef;
}

/* Save Toast Styles */
.save-toast {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #198754;
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    font-weight: 500;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 9999;
    opacity: 0;
    transform: translateY(-20px);
    transition: all 0.3s ease;
    pointer-events: none;
}

.save-toast.show {
    opacity: 1;
    transform: translateY(0);
}

/* Reuse and Save buttons use the same base styling as other nav-tabs */
/* No special styling needed - they inherit from .nav-tabs .nav-link */
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const rosterId = {{ roster.id }};
    const teamSecret = '{{ team.manager_secret }}';
    const inningsPerGame = {{ innings_per_game }};
    const allowBenchedPlayers = {{ allow_benched_players|lower }};
    const infieldPositions = {{ infield_positions_json|safe }};

    // Bootstrap tooltips will be initialized dynamically in validateLineupPlayers

    // Initialize manual save button
    const saveBtn = document.getElementById('manualSaveBtn');
    const saveToast = document.getElementById('saveToast');

    saveBtn.addEventListener('click', function() {
        showSaveToast();
    });

    function showSaveToast() {
        saveToast.classList.add('show');
        setTimeout(() => {
            saveToast.classList.remove('show');
        }, 2000);
    }

    // Initialize PDF button
    const pdfBtn = document.getElementById('pdfBtn');
    pdfBtn.addEventListener('click', function() {
        generateLineupPDF();
    });

    function generateLineupPDF() {
        const lineupTable = document.getElementById('lineupTable');
        if (!lineupTable) {
            alert('Lineup table not found');
            return;
        }

        // Clone the table for modification
        const tableClone = lineupTable.cloneNode(true);

        // Remove drag column (first column) and validation column (last column)
        const rows = tableClone.querySelectorAll('tr');
        rows.forEach(row => {
            // Remove first cell (drag handle)
            if (row.cells.length > 0) {
                row.deleteCell(0);
            }
            // Remove last cell (validation)
            if (row.cells.length > 0) {
                row.deleteCell(row.cells.length - 1);
            }
        });

        // Build the HTML for the print window
        const printContent = `
            <!DOCTYPE html>
            <html>
            <head>
                <title>Lineup - {{ team.name }}</title>
                <style>
                    @page {
                        size: landscape;
                        margin: 0.5in;
                    }
                    * {
                        box-sizing: border-box;
                    }
                    body {
                        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
                        padding: 20px;
                        margin: 0;
                    }
                    .header {
                        text-align: center;
                        margin-bottom: 20px;
                        padding-bottom: 15px;
                        border-bottom: 2px solid #333;
                    }
                    .header h1 {
                        margin: 0 0 5px 0;
                        font-size: 24px;
                    }
                    .header .game-info {
                        color: #666;
                        font-size: 14px;
                    }
                    table {
                        width: 100%;
                        border-collapse: collapse;
                        font-size: 12px;
                    }
                    th, td {
                        border: 1px solid #ccc;
                        padding: 8px 6px;
                        text-align: center;
                    }
                    th {
                        background-color: #f5f5f5;
                        font-weight: 600;
                    }
                    td:nth-child(2) {
                        text-align: left;
                        font-weight: 500;
                    }
                    tr:nth-child(even) {
                        background-color: #fafafa;
                    }
                    .footer {
                        margin-top: 20px;
                        text-align: center;
                        font-size: 11px;
                        color: #999;
                    }
                </style>
            </head>
            <body>
                <div class="header">
                    <h1>{{ team.name }} - Batting Lineup</h1>
                    <div class="game-info">
                        vs {{ opposing_team.name|default:"TBD" }} | {{ event_time_display }}{% if roster.event.location %} | {{ roster.event.location }}{% endif %}
                    </div>
                </div>
                ${tableClone.outerHTML}
                <div class="footer">
                    Generated on ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}
                </div>
            </body>
            </html>
        `;

        // Open a new window and print
        const printWindow = window.open('', '_blank');
        printWindow.document.write(printContent);
        printWindow.document.close();

        // Wait for content to load then print
        printWindow.onload = function() {
            printWindow.print();
        };
    }

    // Initialize reuse roster modal
    const reuseRosterModal = document.getElementById('reuseRosterModal');
    const previousGameSelect = document.getElementById('previousGameSelect');
    const loadPreviousRosterBtn = document.getElementById('loadPreviousRosterBtn');
    const noGamesMessage = document.getElementById('noGamesMessage');

    // Load previous games when modal opens
    reuseRosterModal.addEventListener('show.bs.modal', async function() {
        previousGameSelect.innerHTML = '<option value="">-- Loading... --</option>';
        loadPreviousRosterBtn.disabled = true;
        noGamesMessage.style.display = 'none';

        try {
            const response = await fetch(`/teams/${teamSecret}/roster/${rosterId}/previous-games/`);
            const data = await response.json();

            if (data.success && data.games.length > 0) {
                previousGameSelect.innerHTML = '<option value="">-- Select a game --</option>';
                data.games.forEach(game => {
                    const option = document.createElement('option');
                    option.value = game.roster_id;
                    option.textContent = `${game.date} - vs ${game.opponent}`;
                    previousGameSelect.appendChild(option);
                });
            } else {
                previousGameSelect.innerHTML = '<option value="">-- No previous games --</option>';
                noGamesMessage.style.display = 'block';
            }
        } catch (error) {
            console.error('Error loading previous games:', error);
            previousGameSelect.innerHTML = '<option value="">-- Error loading games --</option>';
        }
    });

    // Enable/disable load button based on selection
    previousGameSelect.addEventListener('change', function() {
        loadPreviousRosterBtn.disabled = !this.value;
    });

    // Handle load roster button click
    loadPreviousRosterBtn.addEventListener('click', async function() {
        const sourceRosterId = previousGameSelect.value;
        if (!sourceRosterId) return;

        this.disabled = true;
        this.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Loading...';

        try {
            const formData = new FormData();
            formData.append('source_roster_id', sourceRosterId);

            const response = await fetch(`/teams/${teamSecret}/roster/${rosterId}/copy-roster/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: formData
            });

            const data = await response.json();

            if (data.success) {
                // Close modal and reload page to show new data
                bootstrap.Modal.getInstance(reuseRosterModal).hide();
                location.reload();
            } else {
                alert('Error loading roster: ' + (data.error || 'Unknown error'));
                this.disabled = false;
                this.innerHTML = '<i class="bi bi-arrow-repeat me-1"></i>Load Roster';
            }
        } catch (error) {
            console.error('Error copying roster:', error);
            alert('Error loading roster. Please try again.');
            this.disabled = false;
            this.innerHTML = '<i class="bi bi-arrow-repeat me-1"></i>Load Roster';
        }
    });

    // Initialize share roster modal
    const shareRosterModal = document.getElementById('shareRosterModal');
    const shareInvalidMessage = document.getElementById('shareInvalidMessage');
    const shareValidMessage = document.getElementById('shareValidMessage');
    const sendShareEmailBtn = document.getElementById('sendShareEmailBtn');
    const sharedRosterUrl = document.getElementById('sharedRosterUrl');

    // Check if roster is fully valid
    function isRosterFullyValid() {
        // Check all inning tabs for validity
        for (let inning = 1; inning <= inningsPerGame; inning++) {
            const inningTab = document.querySelector(`#inning${inning}-tab`);
            if (!inningTab.classList.contains('valid')) {
                return false;
            }
        }

        // Check lineup tab for validity
        const lineupTab = document.getElementById('lineup-tab');
        if (!lineupTab.classList.contains('valid')) {
            return false;
        }

        return true;
    }

    // Handle share modal open
    shareRosterModal.addEventListener('show.bs.modal', function() {
        const isValid = isRosterFullyValid();

        if (isValid) {
            shareInvalidMessage.style.display = 'none';
            shareValidMessage.style.display = 'block';
            if (sendShareEmailBtn) {
                sendShareEmailBtn.style.display = 'inline-block';
            }
            // Set the shared roster URL
            if (sharedRosterUrl) {
                sharedRosterUrl.textContent = window.location.origin + '/shared_roster/' + rosterId + '/';
            }
        } else {
            shareInvalidMessage.style.display = 'block';
            shareValidMessage.style.display = 'none';
            if (sendShareEmailBtn) {
                sendShareEmailBtn.style.display = 'none';
            }
        }
    });

    // Handle send share email button
    if (sendShareEmailBtn) {
        sendShareEmailBtn.addEventListener('click', async function() {
            this.disabled = true;
            this.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Sending...';

            try {
                const response = await fetch(`/shared_roster/${rosterId}/send-email/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken'),
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (data.success) {
                    bootstrap.Modal.getInstance(shareRosterModal).hide();
                    // Show success toast
                    const toast = document.createElement('div');
                    toast.className = 'save-toast show';
                    toast.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i>' + data.message;
                    document.querySelector('.roster-container').appendChild(toast);
                    setTimeout(() => toast.remove(), 4000);
                } else {
                    alert('Error sharing roster: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error sharing roster:', error);
                alert('Error sharing roster. Please try again.');
            } finally {
                this.disabled = false;
                this.innerHTML = '<i class="bi bi-envelope me-1"></i>Send Email';
            }
        });
    }

    // Global SVG drag state (shared across all innings)
    let svgDragState = {
        isDragging: false,
        draggedMarker: null,
        playerId: null,
        playerName: null,
        position: null,
        inning: null,
        dragElement: null,
        startX: 0,
        startY: 0
    };

    // Initialize drag and drop for each inning
    for (let inning = 1; inning <= inningsPerGame; inning++) {
        initializeDragAndDrop(inning);
        loadPositions(inning);
    }

    // Initialize reuse inning dropdown event listeners
    for (let inning = 1; inning <= inningsPerGame; inning++) {
        const dropdownEl = document.getElementById(`reuseInningDropdown${inning}`);
        if (dropdownEl) {
            dropdownEl.addEventListener('show.bs.dropdown', function() {
                populateReuseInningDropdown(inning);
            });
        }
    }

    // Global document-level handlers for custom SVG drag (added once)
    document.addEventListener('mousemove', function(e) {
        if (!svgDragState.isDragging) return;

        const inning = svgDragState.inning;
        const playerList = document.querySelector(`#playerList${inning}`);
        const positionMarkers = document.querySelectorAll(`.baseball-field[data-inning="${inning}"] .position-marker`);

        // Update drag element position
        svgDragState.dragElement.style.left = e.clientX + 'px';
        svgDragState.dragElement.style.top = e.clientY + 'px';

        // Check what we're hovering over and update visual indicators
        const elementUnder = document.elementFromPoint(e.clientX, e.clientY);

        // Clear all hover states first
        positionMarkers.forEach(m => {
            m.classList.remove('drag-over');
            m.classList.remove('drag-over-swap');
        });
        playerList.style.backgroundColor = '#f8f9fa';

        if (elementUnder) {
            // Check if hovering over a position marker
            const targetMarker = elementUnder.closest('.position-marker');
            if (targetMarker && targetMarker !== svgDragState.draggedMarker) {
                if (targetMarker.classList.contains('has-player')) {
                    targetMarker.classList.add('drag-over-swap');
                } else {
                    targetMarker.classList.add('drag-over');
                }
            }

            // Check if hovering over player list
            const targetPlayerList = elementUnder.closest('.player-list');
            if (targetPlayerList && targetPlayerList.id === `playerList${inning}`) {
                playerList.style.backgroundColor = '#e7f1ff';
            }
        }
    });

    document.addEventListener('mouseup', function(e) {
        if (!svgDragState.isDragging) return;

        const inning = svgDragState.inning;
        const playerList = document.querySelector(`#playerList${inning}`);
        const positionMarkers = document.querySelectorAll(`.baseball-field[data-inning="${inning}"] .position-marker`);

        // Clean up drag visual
        if (svgDragState.dragElement) {
            svgDragState.dragElement.remove();
        }

        // Clear all hover states
        positionMarkers.forEach(m => {
            m.classList.remove('drag-over');
            m.classList.remove('drag-over-swap');
            m.style.opacity = '1';
        });
        playerList.style.backgroundColor = '#f8f9fa';

        // Restore source marker opacity
        if (svgDragState.draggedMarker) {
            svgDragState.draggedMarker.style.opacity = '1';
        }

        // Check what we're dropping on
        const elementUnder = document.elementFromPoint(e.clientX, e.clientY);

        if (elementUnder) {
            // Check if dropping on a position marker
            const targetMarker = elementUnder.closest('.position-marker');
            if (targetMarker && targetMarker !== svgDragState.draggedMarker) {
                // Perform the drop on position marker
                handleSvgPositionDrop(targetMarker, svgDragState);
            }

            // Check if dropping on player list (unassign)
            const targetPlayerList = elementUnder.closest('.player-list');
            if (targetPlayerList && targetPlayerList.id === `playerList${inning}`) {
                // Unassign the player
                handleSvgPlayerListDrop(svgDragState);
            }
        }

        // Reset drag state
        svgDragState = {
            isDragging: false,
            draggedMarker: null,
            playerId: null,
            playerName: null,
            position: null,
            inning: null,
            dragElement: null,
            startX: 0,
            startY: 0
        };
    });

    function handleSvgPositionDrop(targetMarker, dragState) {
        const inning = dragState.inning;
        const oldMarker = dragState.draggedMarker;
        const oldPosition = dragState.position;
        const playerId = dragState.playerId;
        const playerName = dragState.playerName;
        const newPosition = targetMarker.dataset.position;

        // Check if target has a player (swap scenario)
        if (targetMarker.classList.contains('has-player')) {
            // SWAP: Get current player info from target position
            const targetNameDisplay = targetMarker.querySelector('.player-name-display');
            const targetPlayerName = targetNameDisplay.textContent;

            // Find target player's ID
            const targetPlayerCard = Array.from(document.querySelectorAll(`#playerList${inning} .player-card`))
                .find(card => card.dataset.playerName === targetPlayerName);
            const targetPlayerId = targetPlayerCard ? targetPlayerCard.dataset.playerId : '';

            // Move target player to old position
            const oldNameDisplay = oldMarker.querySelector('.player-name-display');
            oldNameDisplay.textContent = targetPlayerName;
            oldMarker.classList.add('has-player');
            const oldRemoveBtn = oldMarker.querySelector('.remove-player-btn');
            if (oldRemoveBtn) {
                oldRemoveBtn.style.display = 'block';
            }

            // Save target player to old position
            savePosition(inning, oldPosition, targetPlayerId, targetPlayerName);

            // Update target position with dragged player
            targetNameDisplay.textContent = playerName;
            targetMarker.classList.add('has-player');
            const targetRemoveBtn = targetMarker.querySelector('.remove-player-btn');
            if (targetRemoveBtn) {
                targetRemoveBtn.style.display = 'block';
            }

            // Save dragged player to new position
            savePosition(inning, newPosition, playerId, playerName);
        } else {
            // No swap - just move to empty position
            // Clear old position
            const oldNameDisplay = oldMarker.querySelector('.player-name-display');
            oldNameDisplay.textContent = '';
            oldMarker.classList.remove('has-player');
            const oldRemoveBtn = oldMarker.querySelector('.remove-player-btn');
            if (oldRemoveBtn) {
                oldRemoveBtn.style.display = 'none';
            }
            savePosition(inning, oldPosition, '', '');

            // Set new position
            const targetNameDisplay = targetMarker.querySelector('.player-name-display');
            targetNameDisplay.textContent = playerName;
            targetMarker.classList.add('has-player');
            const targetRemoveBtn = targetMarker.querySelector('.remove-player-btn');
            if (targetRemoveBtn) {
                targetRemoveBtn.style.display = 'block';
            }
            savePosition(inning, newPosition, playerId, playerName);
        }

        // Update validation
        updateInningValidation(inning);
        updateAllAssignedMessage(inning);
    }

    function handleSvgPlayerListDrop(dragState) {
        const inning = dragState.inning;
        const oldMarker = dragState.draggedMarker;
        const oldPosition = dragState.position;
        const playerId = dragState.playerId;

        // Clear the old position
        const oldNameDisplay = oldMarker.querySelector('.player-name-display');
        oldNameDisplay.textContent = '';
        oldMarker.classList.remove('has-player');
        const oldRemoveBtn = oldMarker.querySelector('.remove-player-btn');
        if (oldRemoveBtn) {
            oldRemoveBtn.style.display = 'none';
        }

        // Show the player card in Available Players list
        const playerCard = document.querySelector(`#playerList${inning} .player-card[data-player-id="${playerId}"]`);
        if (playerCard) {
            playerCard.classList.remove('assigned');
        }

        // Save the unassignment
        savePosition(inning, oldPosition, '', '');

        // Update validation
        updateInningValidation(inning);
        updateAllAssignedMessage(inning);
    }

    // Initialize reset inning modal
    const resetInningModal = new bootstrap.Modal(document.getElementById('resetInningModal'));
    let pendingResetInning = null;

    document.querySelectorAll('.reset-inning-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            const inning = parseInt(this.dataset.inning);
            pendingResetInning = inning;
            document.getElementById('resetInningNumber').textContent = `Inning ${inning}`;
            resetInningModal.show();
        });
    });

    document.getElementById('confirmResetInningBtn').addEventListener('click', function() {
        if (pendingResetInning !== null) {
            resetInning(pendingResetInning);
            resetInningModal.hide();
            pendingResetInning = null;
        }
    });

    async function resetInning(inning) {
        const field = document.querySelector(`.baseball-field[data-inning="${inning}"]`);
        const playerList = document.querySelector(`#playerList${inning}`);

        // Clear all positions
        const markers = field.querySelectorAll('.position-marker');
        for (const marker of markers) {
            const position = marker.dataset.position;
            const nameDisplay = marker.querySelector('.player-name-display');
            const removeBtn = marker.querySelector('.remove-player-btn');

            nameDisplay.textContent = '';
            marker.classList.remove('has-player');
            if (removeBtn) removeBtn.style.display = 'none';

            await savePosition(inning, position, '', '');
        }

        // Reset all player cards to unassigned
        playerList.querySelectorAll('.player-card').forEach(card => {
            card.classList.remove('assigned');
        });

        // Update validation and message
        updateInningValidation(inning);
        updateAllAssignedMessage(inning);
    }

    async function cloneInning(sourceInning, targetInning) {
        console.log('cloneInning called:', sourceInning, '->', targetInning);

        // Get all position assignments from source inning - use .baseball-field to be specific
        const sourceField = document.querySelector(`.baseball-field[data-inning="${sourceInning}"]`);
        const targetField = document.querySelector(`.baseball-field[data-inning="${targetInning}"]`);
        const targetPlayerList = document.querySelector(`#playerList${targetInning}`);

        console.log('sourceField:', sourceField);
        console.log('targetField:', targetField);
        console.log('targetPlayerList:', targetPlayerList);

        if (!sourceField || !targetField || !targetPlayerList) {
            console.error('Missing elements for clone operation');
            return;
        }

        // First, clear all positions in target inning (UI and database)
        const targetMarkers = targetField.querySelectorAll('.position-marker');
        for (const marker of targetMarkers) {
            const position = marker.dataset.position;
            const nameDisplay = marker.querySelector('.player-name-display');
            const removeBtn = marker.querySelector('.remove-player-btn');

            // Clear UI
            nameDisplay.textContent = '';
            marker.classList.remove('has-player');
            if (removeBtn) removeBtn.style.display = 'none';

            // Clear from database
            await savePosition(targetInning, position, '', '');
        }

        // Reset all player cards in target inning to unassigned
        targetPlayerList.querySelectorAll('.player-card').forEach(card => {
            card.classList.remove('assigned');
        });

        // Get assignments from source inning and apply to target
        const sourceMarkers = sourceField.querySelectorAll('.position-marker.has-player');

        for (const sourceMarker of sourceMarkers) {
            const position = sourceMarker.dataset.position;
            const playerName = sourceMarker.querySelector('.player-name-display').textContent;

            // Find the corresponding target marker
            const targetMarker = targetField.querySelector(`.position-marker[data-position="${position}"]`);
            if (!targetMarker) continue;

            // Find the player card in target inning by name
            const playerCard = Array.from(targetPlayerList.querySelectorAll('.player-card'))
                .find(card => card.dataset.playerName === playerName);
            if (!playerCard) continue;

            const playerId = playerCard.dataset.playerId;

            // Update target marker display
            const nameDisplay = targetMarker.querySelector('.player-name-display');
            nameDisplay.textContent = playerName;
            targetMarker.classList.add('has-player');

            const removeBtn = targetMarker.querySelector('.remove-player-btn');
            if (removeBtn) removeBtn.style.display = 'block';

            // Hide player card
            playerCard.classList.add('assigned');

            // Save to database
            await savePosition(targetInning, position, playerId, playerName);
        }

        // Update validation and message for target inning
        updateInningValidation(targetInning);
        updateAllAssignedMessage(targetInning);

        // Show success feedback
        const targetTab = document.querySelector(`#inning${targetInning}-tab`);
        targetTab.style.transition = 'background-color 0.3s';
        targetTab.style.backgroundColor = '#d1e7dd';
        setTimeout(() => {
            targetTab.style.backgroundColor = '';
        }, 1000);
    }

    function initializeDragAndDrop(inning) {
        const playerCards = document.querySelectorAll(`#playerList${inning} .player-card`);
        const positionMarkers = document.querySelectorAll(`.baseball-field[data-inning="${inning}"] .position-marker`);
        const playerList = document.querySelector(`#playerList${inning}`);

        // Make player cards draggable
        playerCards.forEach(card => {
            card.addEventListener('dragstart', function(e) {
                e.dataTransfer.setData('playerId', this.dataset.playerId);
                e.dataTransfer.setData('playerName', this.dataset.playerName);
                e.dataTransfer.setData('source', 'playerList');

                // Create a custom drag image
                const dragImage = this.cloneNode(true);
                dragImage.style.position = 'absolute';
                dragImage.style.top = '-1000px';
                dragImage.style.opacity = '0.8';
                dragImage.style.pointerEvents = 'none';
                document.body.appendChild(dragImage);
                e.dataTransfer.setDragImage(dragImage, 0, 0);

                // Clean up drag image after drag starts
                setTimeout(() => {
                    document.body.removeChild(dragImage);
                }, 0);

                this.classList.add('dragging');
            });

            card.addEventListener('dragend', function() {
                this.classList.remove('dragging');
            });
        });

        // Make position markers droppable and draggable
        positionMarkers.forEach(marker => {
            // Click handler for remove button
            const removeBtn = marker.querySelector('.remove-player-btn');
            if (removeBtn) {
                removeBtn.addEventListener('click', function(e) {
                    e.stopPropagation();

                    const nameDisplay = marker.querySelector('.player-name-display');
                    const playerName = nameDisplay.textContent;
                    const position = marker.dataset.position;

                    // Find the player card by name
                    const playerCard = Array.from(document.querySelectorAll(`#playerList${inning} .player-card`))
                        .find(card => card.dataset.playerName === playerName);

                    if (!playerCard) return;

                    // Clear the position
                    nameDisplay.textContent = '';
                    marker.classList.remove('has-player');
                    removeBtn.style.display = 'none';

                    // Show the player card in Available Players list
                    playerCard.classList.remove('assigned');

                    // Save the unassignment
                    savePosition(inning, position, '', '');

                    // Update inning validation and message
                    updateInningValidation(inning);
                    updateAllAssignedMessage(inning);
                });
            }

            // Custom mouse-based drag for SVG position markers
            // Attach to the circle element which receives clicks
            const positionCircle = marker.querySelector('.position-circle');
            if (positionCircle) {
                positionCircle.addEventListener('mousedown', handleMarkerMouseDown);
            }
            // Also attach to the text elements
            const positionLabel = marker.querySelector('.position-label');
            const playerNameDisplay = marker.querySelector('.player-name-display');
            if (positionLabel) {
                positionLabel.addEventListener('mousedown', handleMarkerMouseDown);
            }
            if (playerNameDisplay) {
                playerNameDisplay.addEventListener('mousedown', handleMarkerMouseDown);
            }

            function handleMarkerMouseDown(e) {
                // Don't start drag if clicking the remove button
                if (e.target.closest('.remove-player-btn')) return;

                // Only allow drag if position has a player
                if (!marker.classList.contains('has-player')) return;

                const nameDisplay = marker.querySelector('.player-name-display');
                const playerName = nameDisplay.textContent;
                const position = marker.dataset.position;

                // Find the player ID by matching the player name
                const playerCard = Array.from(document.querySelectorAll(`#playerList${inning} .player-card`))
                    .find(card => card.dataset.playerName === playerName);

                if (!playerCard) return;

                e.preventDefault();

                // Create drag element (visual feedback)
                const dragElement = document.createElement('div');
                dragElement.className = 'player-card';
                dragElement.style.position = 'fixed';
                dragElement.style.zIndex = '10000';
                dragElement.style.opacity = '0.8';
                dragElement.style.pointerEvents = 'none';
                dragElement.style.transform = 'translate(-50%, -50%)';
                dragElement.style.width = '150px';
                dragElement.style.left = e.clientX + 'px';
                dragElement.style.top = e.clientY + 'px';
                dragElement.textContent = playerName;
                document.body.appendChild(dragElement);

                // Set drag state (using global svgDragState)
                svgDragState = {
                    isDragging: true,
                    draggedMarker: marker,
                    playerId: playerCard.dataset.playerId,
                    playerName: playerName,
                    position: position,
                    inning: inning,
                    dragElement: dragElement,
                    startX: e.clientX,
                    startY: e.clientY
                };

                // Visual feedback on source marker
                marker.style.opacity = '0.5';
            }

            // Keep the standard HTML5 drag handlers for compatibility
            marker.addEventListener('dragstart', function(e) {
                if (!this.classList.contains('has-player')) {
                    e.preventDefault();
                    return false;
                }

                const nameDisplay = this.querySelector('.player-name-display');
                const playerName = nameDisplay.textContent;
                const position = this.dataset.position;

                // Find the player ID by matching the player name
                const playerCard = Array.from(document.querySelectorAll(`#playerList${inning} .player-card`))
                    .find(card => card.dataset.playerName === playerName);

                if (playerCard) {
                    e.dataTransfer.setData('playerId', playerCard.dataset.playerId);
                    e.dataTransfer.setData('playerName', playerName);
                    e.dataTransfer.setData('position', position);
                    e.dataTransfer.setData('source', 'position');
                    e.dataTransfer.effectAllowed = 'move';

                    this.style.opacity = '0.5';
                } else {
                    e.preventDefault();
                    return false;
                }
            });

            marker.addEventListener('dragend', function() {
                this.style.opacity = '1';
            });

            // Position marker as drop zone
            marker.addEventListener('dragover', function(e) {
                e.preventDefault();
                // Check if we're dragging from another position (swap allowed) or player list
                const isFromPosition = e.dataTransfer.types.includes('text/plain');

                if (this.classList.contains('has-player')) {
                    // Position is occupied - show swap indicator (blue) if from position, red if from player list
                    // We can't reliably check source during dragover, so we'll use a swap-style indicator
                    this.classList.add('drag-over-swap');
                    this.classList.remove('drag-over');
                } else {
                    this.classList.add('drag-over');
                    this.classList.remove('drag-over-swap');
                }
            });

            marker.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
                this.classList.remove('drag-over-swap');
            });

            marker.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');
                this.classList.remove('drag-over-swap');

                const playerId = e.dataTransfer.getData('playerId');
                const playerName = e.dataTransfer.getData('playerName');
                const position = this.dataset.position;
                const source = e.dataTransfer.getData('source');

                // If dropping from player list, check if this player is already assigned to another position
                if (source === 'playerList') {
                    const existingMarker = Array.from(document.querySelectorAll(`.baseball-field[data-inning="${inning}"] .position-marker.has-player`))
                        .find(m => m.querySelector('.player-name-display').textContent === playerName);

                    if (existingMarker && existingMarker !== this) {
                        // Player is already assigned elsewhere - unassign from old position first
                        const oldPosition = existingMarker.dataset.position;
                        const oldNameDisplay = existingMarker.querySelector('.player-name-display');
                        oldNameDisplay.textContent = '';
                        existingMarker.classList.remove('has-player');
                        const oldRemoveBtn = existingMarker.querySelector('.remove-player-btn');
                        if (oldRemoveBtn) {
                            oldRemoveBtn.style.display = 'none';
                        }
                        // Save the unassignment
                        savePosition(inning, oldPosition, '', '');
                    }
                }

                // If position is already occupied and we're dropping from player list
                if (this.classList.contains('has-player') && source === 'playerList') {
                    // Swap: unassign current player and assign the new one
                    const currentNameDisplay = this.querySelector('.player-name-display');
                    const currentPlayerName = currentNameDisplay.textContent;

                    // Find current player's card and mark as unassigned (return to Available Players)
                    const currentPlayerCard = Array.from(document.querySelectorAll(`#playerList${inning} .player-card`))
                        .find(card => card.dataset.playerName === currentPlayerName);
                    if (currentPlayerCard) {
                        currentPlayerCard.classList.remove('assigned');
                    }
                    // Continue to assign the new player below...
                }

                // If dragging from another position
                if (source === 'position') {
                    const oldPosition = e.dataTransfer.getData('position');
                    const oldMarker = document.querySelector(`.baseball-field[data-inning="${inning}"] .position-marker[data-position="${oldPosition}"]`);

                    if (oldMarker && oldMarker !== this) {
                        // Check if target position has a player (swap scenario)
                        if (this.classList.contains('has-player')) {
                            // SWAP: Get current player info from target position
                            const targetNameDisplay = this.querySelector('.player-name-display');
                            const targetPlayerName = targetNameDisplay.textContent;

                            // Find target player's ID
                            const targetPlayerCard = Array.from(document.querySelectorAll(`#playerList${inning} .player-card`))
                                .find(card => card.dataset.playerName === targetPlayerName);
                            const targetPlayerId = targetPlayerCard ? targetPlayerCard.dataset.playerId : '';

                            // Move target player to old position
                            const oldNameDisplay = oldMarker.querySelector('.player-name-display');
                            oldNameDisplay.textContent = targetPlayerName;
                            oldMarker.classList.add('has-player');
                            const oldRemoveBtn = oldMarker.querySelector('.remove-player-btn');
                            if (oldRemoveBtn) {
                                oldRemoveBtn.style.display = 'block';
                            }

                            // Save target player to old position
                            savePosition(inning, oldPosition, targetPlayerId, targetPlayerName);
                        } else {
                            // Not a swap - just clear old position
                            const oldNameDisplay = oldMarker.querySelector('.player-name-display');
                            oldNameDisplay.textContent = '';
                            oldMarker.classList.remove('has-player');
                            const oldRemoveBtn = oldMarker.querySelector('.remove-player-btn');
                            if (oldRemoveBtn) {
                                oldRemoveBtn.style.display = 'none';
                            }
                            savePosition(inning, oldPosition, '', '');
                        }
                    }
                }

                // Update display for the drop target
                const nameDisplay = this.querySelector('.player-name-display');
                nameDisplay.textContent = playerName;
                this.classList.add('has-player');

                // Show remove button
                const removeBtn = this.querySelector('.remove-player-btn');
                if (removeBtn) {
                    removeBtn.style.display = 'block';
                }

                // Hide player card from Available Players list
                const playerCard = document.querySelector(`#playerList${inning} .player-card[data-player-id="${playerId}"]`);
                if (playerCard) {
                    playerCard.classList.add('assigned');
                }

                // Save to database
                savePosition(inning, position, playerId, playerName);

                // Update inning validation and message
                updateInningValidation(inning);
                updateAllAssignedMessage(inning);
            });
        });

        // Make player list a drop zone for unassigning players
        playerList.addEventListener('dragover', function(e) {
            const source = e.dataTransfer.types.includes('text/plain') ? 'unknown' : 'position';
            // Only allow drops from positions, not from the player list itself
            if (source !== 'playerList') {
                e.preventDefault();
                this.style.backgroundColor = '#e7f1ff';
            }
        });

        playerList.addEventListener('dragleave', function(e) {
            this.style.backgroundColor = '#f8f9fa';
        });

        playerList.addEventListener('drop', function(e) {
            e.preventDefault();
            this.style.backgroundColor = '#f8f9fa';

            const source = e.dataTransfer.getData('source');

            // Only allow unassigning from positions, not moving within player list
            if (source !== 'position') {
                return;
            }

            const playerId = e.dataTransfer.getData('playerId');
            const position = e.dataTransfer.getData('position');

            // Clear the position marker
            const marker = document.querySelector(`.baseball-field[data-inning="${inning}"] .position-marker[data-position="${position}"]`);
            if (marker) {
                const nameDisplay = marker.querySelector('.player-name-display');
                nameDisplay.textContent = '';
                marker.classList.remove('has-player');
                const removeBtn = marker.querySelector('.remove-player-btn');
                if (removeBtn) {
                    removeBtn.style.display = 'none';
                }
            }

            // Show the player card in the Available Players list again
            const playerCard = document.querySelector(`#playerList${inning} .player-card[data-player-id="${playerId}"]`);
            if (playerCard) {
                playerCard.classList.remove('assigned');
            }

            // Save the unassignment to database
            savePosition(inning, position, '', '');

            // Update inning validation and message
            updateInningValidation(inning);
            updateAllAssignedMessage(inning);
        });
    }

    function updateInningValidation(inning) {
        const playerList = document.querySelector(`#playerList${inning}`);
        const inningTab = document.querySelector(`#inning${inning}-tab`);
        const allowBenchedPlayers = {{ allow_benched_players|lower }};
        const fieldContainer = document.querySelector(`.baseball-field[data-inning="${inning}"]`);

        const totalPositions = fieldContainer.querySelectorAll('.position-marker').length;
        const filledPositions = fieldContainer.querySelectorAll('.position-marker.has-player').length;
        const totalPlayers = playerList.querySelectorAll('.player-card').length;
        const unassignedPlayers = playerList.querySelectorAll('.player-card:not(.assigned)').length;

        let isValid = false;

        if (allowBenchedPlayers) {
            // Mode 1: Allow benched players
            if (totalPlayers >= totalPositions) {
                // Enough or more players than positions - all positions must be filled
                isValid = (totalPositions === filledPositions);
            } else {
                // Fewer players than positions (e.g., some didn't show up) - all players must be assigned
                isValid = (unassignedPlayers === 0);
            }
        } else {
            // Mode 2: Don't allow benched players - all players must be assigned
            // (If more players than positions, this will be impossible - intentional)
            isValid = (unassignedPlayers === 0);
        }

        if (isValid) {
            inningTab.classList.add('valid');
        } else {
            inningTab.classList.remove('valid');
        }

        return isValid;
    }

    function updateAllAssignedMessage(inning) {
        const playerList = document.querySelector(`#playerList${inning}`);
        const message = document.querySelector(`#allAssignedMessage${inning}`);
        const inningTab = document.querySelector(`#inning${inning}-tab`);

        const unassignedPlayers = playerList.querySelectorAll('.player-card:not(.assigned)');
        const allAssigned = unassignedPlayers.length === 0;
        const isValid = inningTab.classList.contains('valid');

        if (allAssigned) {
            message.style.display = 'flex';
            // Show/hide the "Inning is now valid" text based on validation state
            const validText = message.querySelector('.inning-valid-text');
            if (validText) {
                validText.style.display = isValid ? 'block' : 'none';
            }
        } else {
            message.style.display = 'none';
        }

        // Update lineup positions and validation immediately
        updateLineupPositionsFromField();
    }

    // Populate reuse inning dropdown when it's about to be shown
    function populateReuseInningDropdown(targetInning) {
        const menu = document.getElementById(`reuseInningMenu${targetInning}`);
        if (!menu) return;

        // Clear existing items
        menu.innerHTML = '';

        // Find all other innings that have at least one position assigned
        const configuredInnings = [];
        for (let otherInning = 1; otherInning <= inningsPerGame; otherInning++) {
            if (otherInning === targetInning) continue;

            const field = document.querySelector(`.baseball-field[data-inning="${otherInning}"]`);
            if (field) {
                const filledPositions = field.querySelectorAll('.position-marker.has-player').length;
                if (filledPositions > 0) {
                    configuredInnings.push(otherInning);
                }
            }
        }

        if (configuredInnings.length === 0) {
            // No other innings configured
            const li = document.createElement('li');
            li.innerHTML = '<span class="dropdown-item text-muted">No other innings configured</span>';
            menu.appendChild(li);
        } else {
            // Add items for each configured inning
            configuredInnings.forEach(sourceInning => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.className = 'dropdown-item';
                a.href = '#';
                a.textContent = `Inning ${sourceInning}`;
                a.dataset.sourceInning = sourceInning;
                a.dataset.targetInning = targetInning;
                a.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const src = parseInt(this.dataset.sourceInning);
                    const tgt = parseInt(this.dataset.targetInning);
                    cloneInning(src, tgt);

                    // Collapse the dropdown
                    const dropdownEl = document.getElementById(`reuseInningDropdown${tgt}`);
                    const bsDropdown = bootstrap.Dropdown.getInstance(dropdownEl.querySelector('.dropdown-toggle'));
                    if (bsDropdown) {
                        bsDropdown.hide();
                    }
                });
                li.appendChild(a);
                menu.appendChild(li);
            });
        }
    }

    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    async function savePosition(inning, position, playerId, playerName) {
        try {
            const formData = new FormData();
            formData.append('inning', inning);
            formData.append('position', position);
            formData.append('player_id', playerId);

            const response = await fetch(`/teams/${teamSecret}/roster/${rosterId}/save-position/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: formData
            });

            const result = await response.json();
            if (!result.success) {
                console.error('Error saving position:', result.error);
                alert('Failed to save position. Please try again.');
            }
        } catch (error) {
            console.error('Error saving position:', error);
            alert('Failed to save position. Please try again.');
        }
    }

    function loadPositions(inning) {
        // Get roster data from the page
        const rosterData = {{ roster_data_json|safe }};
        const inningData = rosterData[`inning_${inning}`];

        if (!inningData || Object.keys(inningData).length === 0) {
            // Still update message even if no data
            updateInningValidation(inning);
            updateAllAssignedMessage(inning);
            return;
        }

        // Load each position
        Object.keys(inningData).forEach(position => {
            const playerId = inningData[position];

            // Find the player card to get the player name
            const playerCard = document.querySelector(`#playerList${inning} .player-card[data-player-id="${playerId}"]`);
            if (!playerCard) return;

            const playerName = playerCard.dataset.playerName;

            // Find the position marker
            const marker = document.querySelector(`.baseball-field[data-inning="${inning}"] .position-marker[data-position="${position}"]`);
            if (!marker) return;

            // Update display
            const nameDisplay = marker.querySelector('.player-name-display');
            nameDisplay.textContent = playerName;
            marker.classList.add('has-player');

            // Show remove button
            const removeBtn = marker.querySelector('.remove-player-btn');
            if (removeBtn) {
                removeBtn.style.display = 'block';
            }

            // Hide player card from Available Players list
            playerCard.classList.add('assigned');
        });

        // Update inning validation and message after loading positions
        updateInningValidation(inning);
        updateAllAssignedMessage(inning);
    }

    // ========== LINEUP TAB FUNCTIONALITY ==========

    // Initialize lineup functionality
    initializeLineup();

    function initializeLineup() {
        const lineupBody = document.getElementById('lineupBody');
        const savedLineup = {{ lineup_data_json|safe }};
        const rosterData = {{ roster_data_json|safe }};

        // Populate the infield positions list at the bottom
        const infieldPositionsList = document.getElementById('infieldPositionsList');
        if (infieldPositionsList) {
            infieldPositionsList.textContent = infieldPositions.join(', ');
        }

        // Get all rows and sort them
        const rows = Array.from(lineupBody.querySelectorAll('.lineup-row'));

        if (savedLineup && savedLineup.length > 0) {
            // Sort by saved lineup order
            sortRowsByLineup(rows, savedLineup);
        } else {
            // Sort alphabetically by default
            sortRowsAlphabetically(rows);
        }

        // Re-append rows in sorted order
        rows.forEach(row => lineupBody.appendChild(row));

        // Update batting order numbers
        updateBattingOrderNumbers();

        // Update position displays from roster data
        updateLineupPositions(rosterData);

        // Initialize drag-and-drop for lineup rows
        initializeLineupDragDrop();

        // Listen for tab switches to update positions
        document.getElementById('lineup-tab').addEventListener('shown.bs.tab', function() {
            updateLineupPositionsFromField();
        });
    }

    function sortRowsByLineup(rows, lineup) {
        rows.sort((a, b) => {
            const aId = a.dataset.playerId;
            const bId = b.dataset.playerId;
            const aIndex = lineup.indexOf(aId);
            const bIndex = lineup.indexOf(bId);

            // If not in lineup, put at end alphabetically
            if (aIndex === -1 && bIndex === -1) {
                return a.dataset.playerName.localeCompare(b.dataset.playerName);
            }
            if (aIndex === -1) return 1;
            if (bIndex === -1) return -1;

            return aIndex - bIndex;
        });
    }

    function sortRowsAlphabetically(rows) {
        rows.sort((a, b) => {
            return a.dataset.playerName.localeCompare(b.dataset.playerName);
        });
    }

    function updateBattingOrderNumbers() {
        const rows = document.querySelectorAll('#lineupBody .lineup-row');
        rows.forEach((row, index) => {
            const orderSpan = row.querySelector('.batting-order');
            orderSpan.textContent = index + 1;
        });
    }

    function updateLineupPositions(rosterData) {
        const rows = document.querySelectorAll('#lineupBody .lineup-row');

        rows.forEach(row => {
            const playerId = row.dataset.playerId;
            let infieldCountFirst3 = 0;

            // Check each inning for this player's position
            for (let inning = 1; inning <= inningsPerGame; inning++) {
                const inningData = rosterData[`inning_${inning}`] || {};
                const positionCell = row.querySelector(`.position-display[data-inning="${inning}"]`);

                if (!positionCell) continue;

                // Find if this player is assigned to any position in this inning
                let playerPosition = '-';
                for (const [position, assignedPlayerId] of Object.entries(inningData)) {
                    if (assignedPlayerId === playerId) {
                        playerPosition = position;
                        break;
                    }
                }

                positionCell.textContent = playerPosition;
                if (playerPosition !== '-') {
                    positionCell.style.color = '#198754';
                    positionCell.style.fontWeight = '500';

                    // Count infield positions in first 3 innings
                    if (inning <= 3 && infieldPositions.includes(playerPosition)) {
                        infieldCountFirst3++;
                    }
                } else {
                    positionCell.style.color = '#6c757d';
                    positionCell.style.fontWeight = 'normal';
                }
            }

            // Update infield count display
            const infieldCountCell = row.querySelector('.infield-count-display');
            if (infieldCountCell) {
                infieldCountCell.textContent = infieldCountFirst3;
                // Color code based on count
                if (infieldCountFirst3 >= 1) {
                    infieldCountCell.style.color = '#198754'; // Green - meets requirement
                } else {
                    infieldCountCell.style.color = '#dc3545'; // Red - doesn't meet requirement
                }
            }
        });

        // Validate players after updating positions
        validateLineupPlayers(rosterData);
    }

    function validateLineupPlayers(rosterData) {
        const rows = document.querySelectorAll('#lineupBody .lineup-row');

        rows.forEach(row => {
            const playerId = row.dataset.playerId;
            const playerName = row.dataset.playerName;
            const validationCell = row.querySelector('.validation-status');
            const validIcon = validationCell.querySelector('.validation-icon-valid');
            const invalidIcon = validationCell.querySelector('.validation-icon-invalid');

            const errors = [];

            // Collect player positions for each inning
            const playerPositions = {};
            for (let inning = 1; inning <= inningsPerGame; inning++) {
                const inningData = rosterData[`inning_${inning}`] || {};
                playerPositions[inning] = null;

                for (const [position, assignedPlayerId] of Object.entries(inningData)) {
                    if (assignedPlayerId === playerId) {
                        playerPositions[inning] = position;
                        break;
                    }
                }
            }

            // Validation 1: Must play infield at least once in first 3 innings
            let playedInfieldFirst3 = false;
            for (let inning = 1; inning <= Math.min(3, inningsPerGame); inning++) {
                const position = playerPositions[inning];
                if (position && infieldPositions.includes(position)) {
                    playedInfieldFirst3 = true;
                    break;
                }
            }

            if (!playedInfieldFirst3) {
                errors.push('Must play an infield position at least once in the first 3 innings.');
            }

            // Validation 2: If benched players not allowed, must have position every inning
            if (!allowBenchedPlayers) {
                const benchedInnings = [];
                for (let inning = 1; inning <= inningsPerGame; inning++) {
                    if (!playerPositions[inning]) {
                        benchedInnings.push(inning);
                    }
                }

                if (benchedInnings.length > 0) {
                    errors.push(`Not assigned a position in inning${benchedInnings.length > 1 ? 's' : ''} ${benchedInnings.join(', ')}.`);
                }
            }

            // Update validation display
            // Dispose existing tooltips from both icons
            let validTooltip = bootstrap.Tooltip.getInstance(validIcon);
            let invalidTooltip = bootstrap.Tooltip.getInstance(invalidIcon);
            if (validTooltip) validTooltip.dispose();
            if (invalidTooltip) invalidTooltip.dispose();

            let tooltipContent = '';

            if (errors.length === 0) {
                validIcon.style.display = 'inline';
                invalidIcon.style.display = 'none';
                tooltipContent = "Player's roster and positions are valid for this game.";
            } else {
                validIcon.style.display = 'none';
                invalidIcon.style.display = 'inline';
                if (errors.length === 1) {
                    tooltipContent = errors[0];
                } else {
                    tooltipContent = errors.map((e, i) => `${i + 1}. ${e}`).join('<br>');
                }
            }

            // Create new tooltip with updated content - attach to the visible icon for better positioning
            const visibleIcon = errors.length === 0 ? validIcon : invalidIcon;
            visibleIcon.setAttribute('title', tooltipContent);
            new bootstrap.Tooltip(visibleIcon, {
                html: true,
                placement: 'left',
                trigger: 'hover'
            });
        });

        // Update Lineup tab validation state
        updateLineupTabValidation();
    }

    function updateLineupTabValidation() {
        const lineupTab = document.getElementById('lineup-tab');
        const invalidPlayers = document.querySelectorAll('#lineupBody .validation-icon-invalid[style*="inline"]');

        if (invalidPlayers.length === 0) {
            lineupTab.classList.add('valid');
        } else {
            lineupTab.classList.remove('valid');
        }
    }

    function updateLineupPositionsFromField() {
        // Build roster data from current field state
        const rosterData = {};

        for (let inning = 1; inning <= inningsPerGame; inning++) {
            const field = document.querySelector(`.baseball-field[data-inning="${inning}"]`);
            if (!field) continue;

            const inningData = {};
            const markers = field.querySelectorAll('.position-marker.has-player');

            markers.forEach(marker => {
                const position = marker.dataset.position;
                const playerName = marker.querySelector('.player-name-display').textContent;

                // Find player ID by name
                const playerCard = document.querySelector(`#playerList${inning} .player-card[data-player-name="${playerName}"]`);
                if (playerCard) {
                    inningData[position] = playerCard.dataset.playerId;
                }
            });

            rosterData[`inning_${inning}`] = inningData;
        }

        updateLineupPositions(rosterData);
        // Validation is now called inside updateLineupPositions
    }

    function initializeLineupDragDrop() {
        const lineupBody = document.getElementById('lineupBody');
        let draggedRow = null;

        lineupBody.querySelectorAll('.lineup-row').forEach(row => {
            row.addEventListener('dragstart', function(e) {
                draggedRow = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            row.addEventListener('dragend', function() {
                this.classList.remove('dragging');
                document.querySelectorAll('.lineup-row.drag-over').forEach(r => {
                    r.classList.remove('drag-over');
                });
                draggedRow = null;
            });

            row.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (this !== draggedRow) {
                    this.classList.add('drag-over');
                }
            });

            row.addEventListener('dragleave', function() {
                this.classList.remove('drag-over');
            });

            row.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');

                if (draggedRow && this !== draggedRow) {
                    // Get all rows
                    const rows = Array.from(lineupBody.querySelectorAll('.lineup-row'));
                    const draggedIndex = rows.indexOf(draggedRow);
                    const dropIndex = rows.indexOf(this);

                    // Insert dragged row at new position
                    if (draggedIndex < dropIndex) {
                        this.parentNode.insertBefore(draggedRow, this.nextSibling);
                    } else {
                        this.parentNode.insertBefore(draggedRow, this);
                    }

                    // Update batting order numbers
                    updateBattingOrderNumbers();

                    // Save the new lineup order
                    saveLineup();
                }
            });
        });
    }

    async function saveLineup() {
        try {
            const rows = document.querySelectorAll('#lineupBody .lineup-row');
            const lineup = Array.from(rows).map(row => row.dataset.playerId);

            const formData = new FormData();
            formData.append('lineup', JSON.stringify(lineup));

            const response = await fetch(`/teams/${teamSecret}/roster/${rosterId}/save-lineup/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: formData
            });

            const result = await response.json();
            if (!result.success) {
                console.error('Error saving lineup:', result.error);
            }
        } catch (error) {
            console.error('Error saving lineup:', error);
        }
    }
});
</script>
{% endblock %}
